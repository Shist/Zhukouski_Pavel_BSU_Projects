import random
import math
import time

def Simple_Generating_of_Prime_16bit():  # Функция, генерирующее обычное 16-битное простое число (проверяет делители до корня из числа)
    q = 0  # Наше число
    prime = False
    while not prime:
        q = random.randrange(16385, 32768)*2 + 1  # рандомное нечётное 16-битное число
        check = True
        for i in range(3, math.ceil(q ** 0.5) + 1, 2):  # Для всех чисел от трёх, до корня нашего числа с шагом два проверяем...
            if q % i == 0:  # Если у числа найдется делитель, то...
                check = False  # Говорим, что оно непростое и...
                break  # Выходим из цикла (после этого попробуем другое число)
        if check:  # Если мы добрались сюда и check остался True, значит число простое
            prime = True
    return q

#  Данная функция генерирует из малых простых чисел еще большие (16 бит --> 32 бит --> 64 бит --> 128 бит --> 256 бит)
def Generate_Nums(r):  # Функция, генерирующее случайное простое число, занимающее r бит памяти (p = 2qN + 1)
    arr = []  # Список, состоящий из 1000 наших простых чисел
    Num_is_new = True
    q = 0
    p = 0
    while True:
        if len(arr) == 1000:
             break  # Как только мы соберём 1000 простых чисел, ломаем цикл
        if Num_is_new:  # Если число новое (мы его генерируем впервые)
            q = Simple_Generating_of_Prime_16bit()  # Генерируем 16-битное простое обычным способом до корня
            p = q  # Присваиваем его в p
            Num_is_new = False  # Говорим, что число уже не новое
        if p.bit_length() == r:  # Если количество бит числа p равно r (r - число бит, введённое пользователем), то...
            arr.append(p)  # Если число p уже достаточной длины, то добавляем его в массив
            Num_is_new = True  # Говорим, что следующее число будет новым (если у нас 1000 еще не собралось)
            continue  # Переходим к началу цикла
        while True:
            N = random.getrandbits(q.bit_length())  # Подбираем рандомное (не обязательно простое) число N, такое, чтобы его количество бит было равно количеству бит текущего число q
            p = 2 * q * N + 1  # Как только подобрали такое число, делаем действие согласно формуле из метода Демитко
            if p.bit_length() == 2 * q.bit_length() and pow(2, 2 * N, p) != 1 and pow(2, 2 * N * q, p) == 1:  # Проверяем три наших условия из теоремы Поклингтона
                q = p  # Если: 1) кол-во бит p равно удовенному кол-ву бит q; 2) 2^(2N) !≡ 1 (mod p); 3) 2^(2NQ) ≡ 1 (mod p), то присваиваем переменной q значение p
                break  # По итогу итерации, наше число осталось простым, но при этом мы увеличили его кол-во бит вдвое
    return arr  # Возвращаем список наших простых чисел


start_time = time.time()  # Начало отсчета времени (для замера скорости программы)
while True:
    bits = int(input("Введите количество бит (например: 16, 32, 64, 128 или 256) для генерируемых чисел: "))
    if bits % 16 == 0:
        break
    else:
        print("Пожалуйста, ведите число бит, кратное 16!")
nums = Generate_Nums(bits)  # Генерация списка из 1000 простых чисел битовой длины bits
print("Сгенерированные простые числа:")
for num in nums:
    print(num)  # Вывод всех наших чисел
itr = int(input("Введите количество итераций: "))  # Количество итераций для наших тестов (влияет на точность тестов)

#  Тест Ферма
#  Если n - простое число, то оно удовлетворяет сравнению a^(n-1) ≡ 1 (mod n), для ∀ a, которое не делится нацело на n
def Farm(n, k):  # Тест Ферма, n - наше число, k - количество оснований (итераций) для выполнения функции
    if n == 1:  # На случай, если попадется единица
        print("Результат работы теста Ферма: ни простое, ни составное\n")
        return 1
    elif n == 2:
        print("Результат работы теста Ферма: простое с вероятностью 100%\n")
        return 0
    elif n == 3:
        print("Результат работы теста Ферма: простое с вероятностью 100%\n")
        return 0
    elif n == 4:
        print("Результат работы теста Ферма: составное с вероятностью 100%\n")
        return 1
    for i in range(k):  # Пока не выполнились все итерации, пробуем подбирать различные a
        a = random.randrange(2, n - 2)  # Подбираем рандомные a, при чём такие, чтобы проверка была эффективной
        mod_a = pow(a, n - 1, n)  # Возводим a в степень num - 1, но при этом сохранем только остаток от n
        if mod_a != 1:  # Если условие НЕ выполняется, то...
            print("Результат работы теста Ферма: составное с вероятностью 100.0 %")  # Говорим, что составное
            return 1
    print("Результат работы теста Ферма: простое с вероятностью ", (1 - 2 ** (-k)) * 100, "%")
    return 0  # Если до сих пор условие выполнялось, то говорим, что число простое с некоторой вероятностью (зависящей от количества произведённых итераций)


def Gcd(a, b):  # НОД
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    gcd = a + b
    return gcd


def jacobiSymbol(a, b):  # Символ Якоби (a — целое число, b — натуральное, нечётное, больше единицы)
    if Gcd(a, b) != 1:
        return 0  # Если числа не взаимо-простые, то сразу возвращается ноль
    r = 1  # здесь будет ответ
    if a < 0:  # Переход к положительным знакам (если они отрицательные)
        a = -a
        if b % 4 == 3:
            r = -r
    while True:  # Избавляемся от чётности числа a (если оно нечётное)
        t = 0
        while not (a & 1):  # Пока a чётное (т.е. пока его последний бит не станет равен 1):
            t += 1
            a >>= 1  # Побитовый сдвиг вправо на 1
        if t & 1:  # Если t - нечётное (последний бит равен 1), то...
            if (b % 8 == 3) or (b % 8 == 5):  # Если b ≡ 3 (mod 8) ИЛИ b ≡ 5 (mod 8), то...
                r = -r  # По алгоритму вычисления символа Якоби делаем r := -r
        if a % 4 == 3 and b % 4 == 3:  # Проверяем квадратичный закон взаимности: если a ≡ 3 (mod 4) И b ≡ 3 (mod 4), то...
            r = -r
        temp = a
        a = b % temp
        b = temp
        if a == 0:
            return r  # В основном возвращает либо 1, либо -1. Иногда возвращает 0.

#  Тест Соловея-Штрассена
#  Если условие a^((n-1)/2) ≡ (a/n) (mod n), где a ∈ ℤ, a < n, НОД(a, n) > 1, (a/n) - символ Якоби, НЕ выполняется, то число n - составное
#  Иначе оно простое с некоторой вероятностью (зависящей от количества итераций k)
def Solovay_Strassen(n, k):  # Тест Соловея-Штрассена, n - наше число, k - количество оснований для выполнения функции
    prime = False
    if n == 1:  # На случай, если попадется единица
        print("Результат работы теста Соловея-Штрассена: ни простое, ни составное\n")
        return 1
    elif n == 2:
        print("Результат работы теста Соловея-Штрассена: простое с вероятностью 100%\n")
        return 0
    elif n == 3:
        print("Результат работы теста Соловея-Штрассена: простое с вероятностью 100%\n")
        return 0
    elif n == 4:
        print("Результат работы теста Соловея-Штрассена: составное с вероятностью 100%\n")
        return 1
    for i in range(k):  # Пока не выполнились все итерации, пробуем подбирать различные a
        prime = False
        a = random.randint(1, n - 1)  # Подбираем случайное целое число a, меньшее n
        j = jacobiSymbol(a, n)  # Число n после нашей генерации ну точно будет нечётным, так что можно его передавать
        if j == 0:  # Если символ Якоби получился равным нулю, то числа не взаимо-просты, поэтому
            break  # Если символ Якоби равен 0, значит нашелся делитель числа n, и число n - составное
        if pow(a, (n - 1) // 2, n) != j % n:  # Проверяем условие теста Соловея-Штрассена, здесь // - целочисленное деление
            break  # Если уловие НЕ выполняется, то число составное
        prime = True  # Если добрались до сюда, значит условие для составного числа не выполнено, и число простое
    if prime:
        print("Результат работы теста Соловея-Штрассена: простое с вероятностью", (1 - 2 ** (-k)) * 100, "%")
        return 0
    else:
        print("Результат работы теста Соловея-Штрассена: составное с вероятностью 100.0 %")
        return 1

#  Тест Миллера-Рабина
#  Пусть n - простое число и n - 1 = (2^s)*d, где d - нечётно. Тогда для любого a ∈ ℤ выполняется...
#  ХОТЯ БЫ ОДНО из двух следующих условий:
#  1) a^d ≡ 1 (mod n); 2) ∃ целое число r < s такое, что (a^d)^(2^r) ≡ -1 (mod n)
def Miller_Rabin(n, k):  # Тест Миллера-Рабина, n - наше число, k - количество оснований для выполнения функции
    if n == 1:  # На случай, если попадется единица
        print("Результат работы теста Миллера-Рабина: ни простое, ни составное\n")
        return 1
    elif n == 2:
        print("Результат работы теста Миллера-Рабина: простое с вероятностью 100%\n")
        return 0
    elif n == 3:
        print("Результат работы теста Миллера-Рабина: простое с вероятностью 100%\n")
        return 0
    elif n == 4:
        print("Результат работы теста Миллера-Рабина: составное с вероятностью 100%\n")
        return 1
    prime = False
    s = 0
    d = n - 1  # d - чётно (пока что), т.к. n - заведомо нечётно (благодаря генератору)
    while d & 1 == 0:  # До тех пор, пока d не станет нечётным (т.е. пока последний бит не станет равным 1), делаем:
        s += 1  # Повышаем степень двойки
        d //= 2  # Делим число d на два; // - целочисленное деление
    for i in range(k):  # Пока не выполнились все итерации, пробуем подбирать различные a
        prime = False
        a = random.randrange(2, n - 2)
        x = pow(a, d, n)  # Расчёт первого условия: x ≡ a^d (nod n)
        if x != 1 and x != n - 1:  # Если 1-ое условие НЕ выполнилось (x ≠ 1), то смотрим, выполняется ли второе...
            r = 1  # Выше мы уже проверили для r = 0
            while r < s and x != n - 1:  # Проверяем, пока r не станет равным s или пока не станет справдливым: x ≡ -1 (mod n)
                x = pow(x, 2, n)  # x = x^2 mod (n)
                r += 1
            if x != n - 1:  # Если в придачу к первым условию не выполнилось еще и второе, то говорим, что число составное
                break
        prime = True  # Если мы дошли сюда, значит хотя бы одно из условий выполнилось и число, вероятно, простое
    if prime:
        print("Результат работы теста Миллера-Рабина: простое с вероятностью ", (1 - 4 ** (-k)) * 100, "%")
        return 0
    else:
        print("Результат работы теста Миллера-Рабина: составное с вероятностью 100.0 %")
        return 1


print()
i = 0
for x in nums:
    check = True
    print("число ", x, ":")
    if Farm(x, itr):  # 0 - простое, 1 - не простое
        check = False
    if Solovay_Strassen(x, itr):  # 0 - простое, 1 - не простое
        check = False
    if Miller_Rabin(x, itr):  # 0 - простое, 1 - не простое
        check = False
    print()
    if check:
        i += 1
print(i, " чисел из ", len(nums), " прошли все тесты")
print("-— %s seconds —-" % (time.time() - start_time))
