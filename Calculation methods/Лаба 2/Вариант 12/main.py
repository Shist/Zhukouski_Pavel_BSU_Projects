import numpy as np
import matplotlib.pyplot as plt

#  Размерность
N = 10

#  Данная матрица A
A = np.array([[5., 3., 3., -4., 5., -5., -4., -5., 0., 2.],
              [5., 3., -1., 2., 3., 0., -4., 1., -4., -5.],
              [10., 6., 2., -3., -2., -2., -1., 0., -3., -5.],
              [20., 12., 4., -5., -1., -4., 4., -2., -2., -4.],
              [40., 24., 8., -10., 5., -1., 5., 2., 0., -3.],
              [80., 48., 16., -20., 10., -12., -3., -3., 3., 2.],
              [160., 96., 32., -40., 20., -24., -3., -4., 1., 4.],
              [320., 192., 64., -80., 40., -48., -6., -11., 0., -3.],
              [640., 384., 128., -160., 80., -96., -12., -22., -5., 2.],
              [-3., -3., 0., 0., 5., 3., -2., 2., 5., -2.]])

#  Данный вектор b
b = np.array([-18., 2., -8., -6., 24., 30., 64., 100., 216., 0.])

#  || Ak*X = b || --> min (Норма невязки)
#  Посчитать норму невязки для текущего k
def ResidualRate(k, x):
    Ak_x = np.dot(A[:, 0:k], x)
    Ak_x_b = Ak_x - b
    return np.linalg.norm(Ak_x_b)


# Посчитать вектор w (омега)
def GetOmega(u, u_shtrih):
    diff = u - u_shtrih
    return diff / np.linalg.norm(diff)


# Посчитать "штрих" для какого-то объекта: obj' = obj - 2(w, obj)w
def GetShtrih(obj, w):
    number = np.dot(w, obj)
    result = obj - 2*number*w
    return result


# Решение обыкновенного СЛАУ (на вход подается верхнетреугольная матрица, на выходе вектор X)
def ResolveSLAU(curr_a, size, curr_b):
    x = np.zeros(size)
    for i in range(size - 1, -1, -1):
        for j in range(size - 1, i - 1, -1):
            curr_b[i] -= curr_a[i][j]*x[j]
        x[i] = curr_b[i] / curr_a[i][i]
    return x


# A = QR методом отражений
def QrDecompositionByReflectionMethod(A, N):

    # Шаг 0
    k_arr = np.arange(1, N + 1)  # Массив абсцисс (k) для графика
    nevyazka_arr = np.zeros(N)  # Массив ординат (значение невязки) для графика

    # Шаг 1
    reflection_matrix = np.zeros((N, N))  # Матрица с векторами отражений (мы их позже будем считать)
    for i in range(N):
        reflection_matrix[:, i] = A[:, i]  # Обновляем текущую матрицу

    # Шаг 2
    reflection_vector_b = np.copy(b)  # Обновляем текущий вектор b

    # Шаг 3
    for k in range(N):  # Для каждой подматрицы (с первыми k столбцами) матрицы A

        # Шаг 4
        u = np.copy(reflection_matrix[k:, k].transpose())  # За U берём нижний кусочек k-ого столбца матрицы A

        # Шаг 5
        u_shtrih = np.zeros(N - k)  # Текущий вектор U' (первый U для текущей матрицы Ak)
        u_shtrih[0] = np.linalg.norm(u)  # U' = (Norm(U1), 0, 0, ..., 0)^T

        # Шаг 6
        reflection_matrix[k:, k] = u_shtrih  # Записываем текущий U' в вектора отражений

        # Шаг 7
        if k != N - 1:
            w = GetOmega(u, u_shtrih)  # Омега w

            # Шаг 8
            curr_b = np.copy(reflection_vector_b[k:])  # Кусочек вектора b
            b_shtrih = GetShtrih(curr_b, w)  # b' = b - 2(w, b)w

            # Шаг 9
            reflection_vector_b[k:] = b_shtrih  # Запоминаем вектор b отражения

            # Шаг 10
            for j in range(k + 1, N):  # U2, U3, U4, ..., U9
                u_next = np.copy(reflection_matrix[k:, j].transpose())  # Считаем следующий Uj
                u_next_shtrih = GetShtrih(u_next, w)  # Считаем следующий U'
                reflection_matrix[k:, j] = u_next_shtrih.transpose()  # Запоминаем его, он нам понадобится дальше

        # Шаг 11
        X = ResolveSLAU(reflection_matrix, k + 1, np.copy(reflection_vector_b))  # Вектор X из k элементов

        nevyazka_arr[k] = ResidualRate(k + 1, X)

        print("For k =", k + 1, ", X =", X, ", ||Ak*X - b|| = ", nevyazka_arr[k])

    # Шаг 12
    plt.semilogy(k_arr, nevyazka_arr)
    plt.xlabel("Количество столбцов подматрицы Ak")
    plt.ylabel("Значение невязки")
    plt.show()

print("Program started work...")
QrDecompositionByReflectionMethod(A, N)
print("Program finished work...")

"""
АЛГОРИТМ, ПО КОТОРОМУ ДЕЙСТВУЕТ ПРОГРАММА (объяснено для N = 10)
0) На этом шаге просто создаю два массива: 1) Первый будет хранить 10 значений невязки, 2) Второй массив просто будет
хранить числа 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 (это наши k), чтобы потом по этим двум массива построить график невязки от k
1) Записываем все данные из матрицы A в матрицу ReflectionMatrix такой же размерности (чтобы не испортить матрицу A)
2) Записываем вектор b в вектор ReflectionVectorB такой же размерности (чтобы не испортить наш вектор b)
Не знаю, нужно ли вообще делать пункты 1) и 2), но почему бы не подстраховаться?
3) Далее, входим в цикл, где будет N итераций, где k = 0, 1, 2, ..., N - 3, N - 2, N - 1, а размерности матрицы
Ak будет соответственно {N}строк x {1, 2, 3, ..., N - 2, N - 1, N}столбцов
4) На каждом шаге мы берём в качестве вектора U нижний кусочек k-ого столбца матрицы (на первой итерации вектор
U будет состоять из одного числа и девяти нулей, на второй итерации будет состоять из двух чисел и восьми нулей, и т.д.)
5) Теперь нам нужно посчитать самый первый вектор U' текущей матрицы Ak, для этого мы создаем нулевой вектор-столбец
такой же размерности, как обычный U, а потом вместо самого первого его числа (самого верхнего в столбце) вписываем
норму от вектора U, и получится наш U'
6) Насчитанный нами U' мы вписываем в соответствующий кусочек соответствующего столбца в матрице ReflectionMatrix
7) Далее, если итерация не последняя (т.е. k != N - 1), то нам также нужно посчитать очередной вектор w (омега). Для
этого считаем его с помощью текущих векторов U и U'.
8) Также берём в качестве текущего вектора b соответствующий кусочек нашего вектора ReflectionVectorB (размера кусочка
зависит от итерации: 1) на первой итерации мы берем вообще все N элементов исходного вектора b, 2) на второй итерации
мы игнорируем самый верхний элемент столбца и берём 9 нижних (при N = 10). Потом из вектора b и омеги считаем вектор b'.
9) Записываем насчитавшийся вектор b' в соответствующий кусочек столбца вектора ReflectionVectorB.
10) Далее, нам нужно циклически посчитать остальные векторы Uj для текущей матрицы Ak. На первой итерации это будут
векторы U2, U3, ..., U9, на второй итерации, нам нужно будет посчитать только U2, U3, ..., U8, а на последней итерации
(где k будет равен N - 1) нам вообще не придется считать следующие векторы Uj. Так вот, размер каждого из этих векторов
равен N - k, т.е. он зависит от текущей итерации (берем первые N - k элементов снизу каждого столбца начиная с k-ого),
затем считаем их штрихи, и все насчитанные Uj' вставляем в соответствующие места нашей матрицы ReflectionMatrix. Это
как если бы мы изначально решали задачу для k = 10, и в 10 этапов считали все эти U1, U2, ..., U10, потом U1, U2, ...,
U9, потом U1, U2, ..., U8, а в конце вообще только один U1 посчитали и все, ведь наша матричка все уменьшается и
уменьшается на одну строку сверху и один столбец слева.
11) И наконец из насчитавшейся матрицы (состоящей из кучи векторов Uj' и вектора b') мы решаем СЛАУ и выводим вектор X,
а затем по формуле и невязку для этого X.
12) Рисуем график зависимости невязки от k (всего в графике будет 10 точек)
"""
