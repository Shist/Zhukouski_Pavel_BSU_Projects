#include <windows.h>
#include <iostream>

#include "ArrData.h"

using namespace std;

DWORD WINAPI MinMaxFunction(LPVOID);
DWORD WINAPI AverageFunction(LPVOID);

// Переменные
double sum;									// Переменная, хранящая сумму всех элементов массива
double avrg;								// Среднее арифметическое значение массива (по умолчанию равно 0.0)
double max_value;							// Максимальное значение в массиве (по умолчанию равно наименьшему числу типа Double)
double min_value;							// Минимальное значение в массиве (по умолчанию равно наибольшему числу типа Double)
int max_i;									// Индекс максимального элемента массива (по умолчанию равен -1)
int min_i;									// Индекс минимального элемента массива (по умолчанию равен -1)

CRITICAL_SECTION cs_console;				// Критическая секция

int main()
{
	setlocale(LC_ALL, "Rus");				// Подключение русского языка

	ArrData* ad = new ArrData;				// Создаем указатель на структуру "Данные массива"

	// Добавление данных в структуру "Данные массива"
	cout << "Введите количество элементов массива: ";
	cin >> (*ad).N;							// Ввод количества элементов с консоли
	(*ad).arr = new double[(*ad).N];		// Выделяем динамическую память под наш массив

	// Ввод элементов массива с консоли
	cout << "Введите элементы массива:\n";
	for (int i = 0; i < (*ad).N; i++)
		cin >> (*ad).arr[i];
	cout << "\n";

	// Вывод элементов массива на консоль (для того, чтобы потом сравнить с итоговым массивом)
	cout << "Введённый массив:\n" << (*ad).arr[0];
	for (int i = 1; i < (*ad).N; i++)
		cout << " " << (*ad).arr[i];
	cout << "\n\n";

	InitializeCriticalSection(&cs_console);	// Инициализация критической секции

	// Создание потока min_max
	HANDLE min_max_Thread = CreateThread(
		NULL,								// Данный аргумент определяет, может ли создаваемый поток быть унаследован дочерним процессом
		0,									// Размер стека в байтах. Если передать 0, то будет использоваться значение по-умолчанию (1 MB)
		MinMaxFunction,						// Адрес функции, которая будет выполняться потоком
		(LPVOID)ad,							// Указатель на переменную, которая будет передана в поток.
		0,									// Флаги создания. Здесь можно отложить запуск выполнения потока. Мы будем запускать поток сразу же, передаём 0.
		NULL);								// Указатель на переменную, куда будет сохранён идентификатор потока. Нам идентификатор не нужен, передаём NULL.

	// Создание потока average
	HANDLE average_Thread = CreateThread(
		NULL,								// Данный аргумент определяет, может ли создаваемый поток быть унаследован дочерним процессом
		0,									// Размер стека в байтах. Если передать 0, то будет использоваться значение по-умолчанию (1 MB)
		AverageFunction,					// Адрес функции, которая будет выполняться потоком
		(LPVOID)ad,							// Указатель на переменную, которая будет передана в поток.
		0,									// Флаги создания. Здесь можно отложить запуск выполнения потока. Мы будем запускать поток сразу же, передаём 0.
		NULL);								// Указатель на переменную, куда будет сохранён идентификатор потока. Нам идентификатор не нужен, передаём NULL.

	// Ждём, пока потоки закончат свою работу
	WaitForSingleObject(min_max_Thread, INFINITE);
	WaitForSingleObject(average_Thread, INFINITE);

	DeleteCriticalSection(&cs_console);		// Удаление критической секции

	CloseHandle(min_max_Thread);			// Закрываем дескриптор первого потока min_max
	CloseHandle(average_Thread);			// Закрываем дескриптор второго потока average

	(*ad).arr[min_i] = avrg;				// Замена элемента с наименьшим значением на элемент со средним значением
	(*ad).arr[max_i] = avrg;				// Замена элемента с наибольшим значением на элемент со средним значением

	// Вывод элементов изменённого массива на консоль
	cout << "Изменённый массив:\n" << (*ad).arr[0];
	for (int i = 1; i < (*ad).N; i++)
		cout << " " << (*ad).arr[i];
	cout << endl;

	delete[](*ad).arr;						// Освобождаем динамическую память от массива

	return 0;
}