#include <iostream>
#include <random> // Подключаем эту библиотеку, чтобы использовать функцию подбора рандомного числа
using namespace std;


int main()
{
	int W; // Объявляем переменную, с помощью которой будет производиться выбор: 1) задать квадратную матрицу или 2) прямоугольную
	cout << "Enter \"1\" if you want to make square matrix or enter \"2\" if you want to make rectangular matrix: ";
	cin >> W; // Ввод единицы или двойки в зависимости от выбора пользователя (форма матрицы)
	if (W != 1 && W != 2) // Защита от дурака
	{
		cout << "Entered value of choice is incorrect!";
		return 1;
	}
	int Q; // Объявляем переменную, с помощью которой будет производиться выбор: 1) задать матрицу рандомно или 2) задать  матрицу с клавиатуры
	cout << "Enter \"1\" if you want to make random elements or enter \"2\" if you want to enter your own elements: ";
	cin >> Q; // Ввод единицы или двойки в зависимости от выбора пользователя (формат ввода значений элементов в матрицу)
	if (Q != 1 && Q != 2) // Защита от дурака
	{
		cout << "Entered value of choice is incorrect!";
		return 2;
	}
	int L; // Объявляем переменную, которая будет хранить значение количества строк в матрице
	if (W == 1) cout << "Enter the number of lines and columns in the matrix: ";
	if (W == 2) cout << "Enter the number of lines in the matrix: ";
	cin >> L; // Ввод количества строк
	if (L < 1 || L > 20) // Защита от дурака (проверка строк на размерность)
	{
		cout << "The entered number of lines or columns is incorrect or it's bigger than 20!" << endl;
		return 3;
	}
	int * * arr = new int * [L]; // Задаем массив из указателей на массивы
	int G; // Объявляем переменную, которая будет хранить значение количества столбцов в матрице
	if (W == 1) G = L; // Если пользователь выбрал квадратную матрицу, то присваиваем значению количества столбцов значение количества строк
	if (W == 2)
	{
		cout << "Enter the number of columns in the array: ";
		cin >> G; // Если пользователь выбрал прямоугольную матрицу, то вводим количество столбцов
		if (G < 1 || G > 20) // Защита от дурака (проверка столбцов на размерность)
		{
			cout << "The entered number of lines or columns is incorrect or it's bigger than 20!" << endl;
			return 4;
		}
	}
	int i; // Объявляем переменную, чтобы работать с внешними циклами
	int j; // Объявляем переменную, чтобы работать с внутренними циклами
	if (Q == 1) // Если Пользователь ввел единицу, то производим рандомный ввод значений в элементы матрицы
	{
		cout << "The entered matrix is the next: " << endl;
		for (i = 0; i < L; i++)
		{
			arr[i] = new int[G]; // Объявляем массивы (строки матрицы) для каждого значения указателя из первого массиве
			random_device generator; // Обращаемся к функции рандома
			uniform_int_distribution<int> distribution(-100, 100); // Задаем интервал, срелди которого будут выбираться рандомный числа
			for (j = 0; j < G; j++)
			{
				arr[i][j] = distribution(generator); // Присваиваем каждому элементу матрицы какое-то число
				cout << arr[i][j] << "\t"; // Вывод элементов матрицы на консоль
			}
			cout << endl;
		}
	}
	if (Q == 2) // Если пользователь ввел двойку, то производим ввод значений в элементы матрицы с клавиатуры
	{
		for (i = 0; i < L; i++)
		{
			arr[i] = new int[G]; // Объявляем массивы (строки матрицы) для каждого значения указателя из первого массива
			cout << "Enter elements of " << i+1 << " line: ";
			for (j = 0; j < G; j++)
			{
				cin >> arr[i][j]; // Присваиваем каждому элементы матрицы определенное число с клавиатуры
			}
		}
		cout << "The entered matrix is the next: " << endl;
		for (i = 0; i < L; i++)
		{
			for (j = 0; j < G; j++)
			{
				cout << arr[i][j] << "\t"; // Вывод элементов матрицы на консоль
			}
			cout << endl << endl;
		}
	}
	int check = 0; // Вводим переменную check, чтобы использовать ее как инкремент для проверки на наличие положительных чисел в столбцах
	int max = -2147483647; // Вводим переменную max, в которой будем хранить и выводить (если понадобится) максимальное значение столбца
	for (i = 0; i < G; i++)
	{
		for (j = 0; j < L; j++)
		{
			if (arr[j][i] > 0) check++; // Если положительный элемент в столбце найден, то добавляем единицу к переменной check
			if (arr[j][i] > max) max = arr[j][i]; // Заранее ищем самый большой элемент в столбце
		}
		if (check == 0) cout << "The maximum element of the " << i + 1 << " column is: " << max << endl; // Если положительных элементов нету, то выводим максимальный элемент
		else
		{
			cout << "There are positive elements in column number " << i+1 << ". Therefore, the maximum element was not displayed" << endl; // Если положительные элементы есть, то не выводим максимальный элемент
			check = 0; // Обнуляем значение переменной check для последующих итераций
		}
		max = -2147483647; // Присваиваем переменной max исходное значение для последующих итераций
	}
	double min = 9223372036854765807.0; // Вводим переменную min, в которой будем хранить значение минимального числа среди средних значений элементов диагоналей, параллельных побочной 
	double med = 0.0; // Вводим переменную med, в которой будем хранить среднее значение элементов той или иной диагонали, параллельной побочной, и (если надо) передавать в переменную min
	if (W == 2)
	{
		cout << "You have chosen a non-square matrix. It is impossible to calculate the minimum value among the average values of the" <<
		" elements of the diagonals parallel to the secondary diagonal, since in not-square matrix, there is no concept secondary diagonal." << endl;
	}
	int k = 0; // Вводим переменную k, которая будет хранить значение того, какую диагональ, параллельную побочной в матрице, мы рассматриваем
    // Переменная k также будет являться постоянным значением суммы индексов всех элементов рассматриваемой диагонали
	int sum = 0; // Вводим переменную sum, в которой будем хранить суммы значений элементов диагоналей
	if (W == 1)
	{
		for (k = 0; k < 2*L - 1; k++) // 2*L-1 - количество диагоналей в матрице, параллельных побочной оси
		{
			for (i = 0; i < L; i++)
			{
				for (j = 0; j < G; j++)
				{
					if (i + j == k)
					{
						sum += arr[i][j]; // Если i+j равны сумме индексов элементов для данной диагонали, то прибавляем к sum еще одно значение
						check++; // Вновь используем переменную check, теперь уже чтобы считать количество прибавленных элементов
					}
				}
			}
			double med = (double)sum / (double)check; // Высчитываем среднее значение среди элементов диагонали
			check = 0; // Обнуляем переменную check для последующих итераций
			if (med < min) min = med; // Если это значение меньше минимума, то присваиваем значению min текущее значение med
			sum = 0; // Обнуляем значение переменной sum для последующий итераций
		}
	}
	if (W == 1) cout << "The minimum value among the average values of the elements of the diagonals parallel to the secondary diagonal is: " << min << endl;
	// Для получения новой (сглаженной) матрицы таких же размеров выделим память для еще одного двумерного динамического массива
	double * * new_arr = new double *[L]; // Создаем новый массив из указателей на новые массивы (строки новой матрицы) 
	for (i = 0; i < L; i++)
	{
		new_arr[i] = new double[G]; // Объявляем массивы (строки матрицы) для каждого значения указателя из первого массиве
		for (j = 0; j < G; j++)
		{
			if ((i == 0) && (j == 0))
			{ // Высчитываем элемент новой матрицы в левом верхнем углу матрицы
				new_arr[i][j] = (double)((arr[i][j + 1] + arr[i + 1][j] + arr[i + 1][j + 1]) / (double)3);
				continue;
			}
			else if ((i == 0) && (j == (G - 1)))
			{ // Высчитываем элемент новой матрицы в правом верхнем углу матрицы
				new_arr[i][j] = (double)((arr[i][j - 1] + arr[i + 1][j] + arr[i + 1][j - 1]) / (double)3);
				continue;
			}
			else if ((i == (L - 1)) && (j == 0))
			{ // Высчитываем элемент новой матрицы в левом нижнем углу матрицы
				new_arr[i][j] = (double)((arr[i - 1][j] + arr[i - 1][j + 1] + arr[i][j + 1]) / (double)3);
				continue;
			}
			else if ((i == (L - 1)) && (j == (G - 1)))
			{ // Высчитываем элемент новой матрицы в правом нижнем углу матрицы
				new_arr[i][j] = (double)((arr[i][j - 1] + arr[i - 1][j] + arr[i - 1][j - 1]) / (double)3);
				continue;
			}
			else if (i == 0)
			{ // Высчитываем не угловые элементы новой матрицы в самой верхней строчке
				new_arr[i][j] = (double)((arr[i][j - 1] + arr[i][j + 1] + arr[i + 1][j - 1] + arr[i + 1][j] + arr[i + 1][j + 1]) / (double)5);
				continue;
			}
			else if (j == 0)
			{ // Высчитываем не угловые элементы новой матрицы в самом левом столбце
				new_arr[i][j] = (double)((arr[i][j + 1] + arr[i - 1][j] + arr[i - 1][j + 1] + arr[i + 1][j] + arr[i + 1][j + 1]) / (double)5);
				continue;
			}
			else if (i == (L - 1))
			{ // Высчитываем не угловые элементы новой матрицы в самой нижней строчке
				 new_arr[i][j] = (double)((arr[i][j - 1] + arr[i][j + 1] + arr[i - 1][j - 1] + arr[i - 1][j] + arr[i - 1][j + 1]) / (double)5);
				continue;
			}
			else if (j == (G - 1))
			{ // Высчитываем не угловые элементы новой матрицы в самом правом столбце
				new_arr[i][j] = (double)((arr[i][j - 1] + arr[i - 1][j - 1] + arr[i - 1][j] + arr[i + 1][j - 1] + arr[i + 1][j]) / (double)5);
				continue;
			}
			else
			{ // Высчитываем все остальные элементы новой матрицы
				new_arr[i][j] = (double)((arr[i - 1][j - 1] + arr[i - 1][j] + arr[i - 1][j + 1] + arr[i][j - 1] + arr[i][j + 1]
				+ arr[i + 1][j - 1] + arr[i + 1][j] + arr[i + 1][j + 1]) / (double)8);
			}
		}
	}
	check = 0; // Вновь используем переменную check, чтобы с ее помощью проверить, есть ли вообще отрицательные элементы в новой матрице
	double m = -9223372036854775808.0; // Введем переменную m, чтобы с помощью нее найти максимальный отрицательный элемент новой матрицы
	int k_i = 0; // Введем переменную k_i, чтобы хранить в ней информацию о том, в какой строке матрицы располагается элемент 
	int k_j = 0; // Введем переменную k_j, чтобы хранить в ней информацию о том, в каком столбце матрицы располагается элемент
	cout << "The new matrix is the next: " << endl; // Вывод новой матрицы на консоль
	for (i = 0; i < L; i++)
	{
		for (j = 0; j < G; j++)
		{
			if (new_arr[i][j] < 0)
			{
				check++; // Если в новой матрице нашлелся отрицательный элемент, то прибавляем к переменной check единицу
				if (new_arr[i][j] > m)
				{
					m = new_arr[i][j]; // Если элемент меньше максимума, то присваиваем значению переменной max значение элемента
					k_i = i; // Запоминаем строку этого элемента
					k_j = j; // Запоминаем столбец этого элемента
				}
			}
			cout << new_arr[i][j] << "\t" << "\t"; // Вывод элементов матрицы на консоль
		}
		cout << endl << endl;
	}
	if (check == 0) cout << "In the new matrix there are no negative elements at all. Therefore, the maximum element was not displayed." << endl;
	if (check != 0)
	{
		cout << "The value of the maximum negative element among the elements of the new matrix is: " << m << endl;
		cout << "This element is located in the " << k_i + 1 << " line and in the " << k_j + 1 << " column of the new matrix" << endl;
	}
	for (i = 0; i < L; i++)
	{
		delete[] arr[i]; // Очистка памяти от массивов, являющихся строками матрицы
		delete[] new_arr[i]; // Очистка памяти от массивов, являющихся строками новой матрицы
	}
	delete[] arr; // Очистка памяти от первого массива (массива с указателями на строки матрицы)
	delete[] new_arr; // Очистка памяти от первого массива (массива с указателями на строки новой матрицы)
	return 0;
}