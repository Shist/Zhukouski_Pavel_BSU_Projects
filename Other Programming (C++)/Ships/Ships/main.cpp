#include <fstream>
#include <string>
#include <list>
#include <exception>
using namespace std;

ifstream OpenFile()
{
	ifstream fin("SHIPS.IN.txt");
	if (!fin.is_open()) // Проверяем файл на открытие
	{
		throw exception("Input file did not open!"); 
	}
	if (fin.peek() == EOF) // Проверяем файл на пустоту
	{
		throw exception("File SHIPS.IN.txt is empty!");
	}
	return fin;
}

template<typename T>
int My_Strlen(T str) // Своя функция strlen (шаблонная)
{
	int i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return i;
}

template<typename T1, typename T2>
void My_strcpy(T1 str1, T2 str2) // Функция для копирования одной строки в другую (шаблонная, для char* и list<string>)
{ // Вставляем в строку str1 строку str2
	int k;
	for (k = 0; k < My_Strlen(str2); k++)
	{
		str1[k] = str2[k];
	}
	str1[k] = '\0'; // Последний элемент получившейся строки закрываем нуль-терминатором
}

int main()
{
	ifstream fin; // Пробуем открыть входной файл
	ofstream fout("SHIPS.OUT.txt"); // Открываем файл, в который будем выводить информацию...
	try
	{
		fin = OpenFile();
	}
	catch (exception &e)
	{
		fout << e.what();
		fout.close();
		return -1;
	}
	list<string> MyList; // Создаем лист, в который будем помещать названия кораблей на рейде
	string ship; // В этой переменной будем хранить название текущего корабля (в типе string)
	bool check = false;
	int pr = 0; // В этой переменной будем хранить номер причала, который освобождается 
	int i = 0;
	int j = 0;
	int t = 0;
	char symbol; // Вводим эту переменную, чтобы читать символы
	char* name_ship = new char[255](); // В этой строке будем хранить считываемое название корабля, чтобы потом присвоить его в элемент массива
	int N = 0; // В этой переменной будем хранить количество причалов
	fin >> N; // Считываем информацию о количестве причалов
	char* *prichal = new char*[N]; // Создаем массив, каждый из элементов которого будет хранить ссылку на название корабля в причале
	for (i = 0; i < N; i++)
	{
		prichal[i] = new char[255]; // Выделяем память под строки, в которых будем хранить названия кораблей
		prichal[i][0] = '\0'; // Зануляем все пока что еще свободные слоты в причалах
	}
	i = 0; // Зануляем перменную i, чтобы потом не было проблем
	while ((symbol = fin.get()) != EOF) // Пока содержимое файла не закончилось, делаем следующее...
	{
		if (symbol == '1') // Случай, когда какой-то корабль прибыл в порт
		{
			symbol = fin.get(); // Избавляемся от пробела
			while ((symbol = fin.get()) != '\n' && symbol != EOF) // Пока не наткнулись на отступ на новую строку или конец файла, ...
			{
				name_ship[i] = symbol; // посимвольно присваиваем в строку name_ship название текущего корабля
				i++;
			}
			for (i = 0; i < N; i++)
			{
				if (prichal[i][0] == '\0') // Ищем свободные причалы
				{
					My_strcpy(prichal[i], name_ship); // Если свободный причал нашелся, то вставляем в строку название корабля
					check = true; // Также ставим флажок на true
					break; // Если нашли причал и присвоили в него название корабля, то уже можно выходить из цикла
				}
			}
			i = 0; // Вновь зануляем переменную i, чтобы потом не было проблем
			if (!check) // Если свободных причалов так и не нашлось, то добавляем корабль в рейд
			{
				ship = (string)name_ship; // Присваиваем переменной ship типа string название корабля типа char*
				MyList.push_back(ship); // Это нужно, чтобы впихнуть этот корабль в рейд
			}
			check = false; // Ставим флажок вновь на false для последующих кораблей
			delete[] name_ship; // Чистим память от названия предыдущего корабля...
			name_ship = new char[255](); // и выделяем новую пустую строчку под новое название последующего корабля
		}
		else if (symbol == '2') // Случай, когда какой-то причал освободился
		{
			fin >> pr; // Вводим данные о номере причалап
			prichal[pr - 1][0] = '\0'; // Причал освобождается
			if (!MyList.empty())
			{
				My_strcpy(prichal[pr - 1], MyList.front()); // Вставляем название корабля, что стоял первым на рейде, в слот этого причала 
				MyList.pop_front(); // Т.к. первый в очереди корабль выплыл из рейда к причалам, то удаляем его из рейда
			}
		}
		else if (symbol == '3') // Случай, когда требуется посмотреть текущую ситуацию на рейде
		{
			fout << "Queue status on the raid:" << endl;
			for (auto it = MyList.begin(); it != MyList.end(); ++it)
			{
				t++;
				check = true; // Если хотя бы 1 корабль в очереди на рейде есть, то ставим флажок на true
				fout << "The " << t << " ship in the queue is " << *it << endl;
			}
			if (!check) // Если же на рейде пока вообще нету кораблей, то...
			{
				fout << "There are no any ships on the raid" << endl; // Говорим, что кораблей на рейде нету
			}
			check = false; // Вновь ставим флажок на false
			t = 0; // Зануляем переменную t для последующих случаев
		}
		else if (symbol == '4') // Случай, когда нужно рассмотреть и вывести ситуацию с причалами
		{
			fout << "Berths' condition:" << endl;
			for (i = 0; i < N; i++)
			{
				if (prichal[i][0] == '\0') // Если причал свободен, то выводим информацию об этом...
				{
					fout << "Berth number №" << i + 1 << ": is free" << endl;
				}
				else // Если же в причале есть корабль, то выводим его название
				{
					fout << "Berth number №" << i + 1 << ": there is a ship named ";
					for (j = 0; j < My_Strlen(prichal[i]); j++)
					{
						fout << prichal[i][j];
					}
					j = 0; // Вновь зануляем переменную j, чтобы потом не было проблем
					fout << endl;
				}
			}
			i = 0; // Вновь зануляем переменную i, чтобы потом не было проблем
		}
	}
	delete[] name_ship; // Чистим память от той строки, на которую указывала наша переменная char* name_ship
	for (i = 0; i < N; i++)
	{
		delete[] prichal[i]; // Чистим память от тех строк, в которых мы хранили названия кораблей в причалах
	}
	delete[] prichal; // И наконец чистим память от массива ссылок на эти названия кораблей
	fin.close(); // Закрываем входной файл 
	fout.close(); // Закрывай выходной файл
	return 0;
}