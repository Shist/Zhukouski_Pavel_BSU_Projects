import matplotlib.pyplot as plt
import numpy as np
import time

# Лабораторная №3, Вариант №5, Задание №5-2, Матрица №4В
# Задание №2. Метод релаксации 1
# 1. Написать программу, которая при данном n решает СЛАУ Anx = bn указанным в варианте методом. Здесь An - разреженные
# матрицы размерности n из списка 2 (см. ниже), указанные в варианте.
# - Матрицу An следует либо хранить в одном из форматов для разреженных матриц, либо сразу реализовать итерационный
# метод, учитывая известную структуру матрицы. Хранить в памяти матрицу An целиком со всеми нулями запрещено!
# - Вектор bn выбирать таким образом, чтобы он соответствовал некоторому заранее заданному решению
# - Критерий остановки итераций: ||AnXk - bn|| < Epsilon
# 2. Подтвердить правильность работы программы на примере нескольких СЛАУ размерности 5-10.
# 3. Построить диаграмму сходимости (общую) для n = 100, 1000, 10000
# 4. Построить диаграмму, в которой по оси абсцисс изменяется n = [10_k/2], k = 1, ..., 12, а на оси оридант отложено
# время работы, которое требуется, чтобы норма невязки не превышала 10^(-8).

# 2. МЕТОД ГАУССА-ЗЕЙДЕЛЯ

# Требуемая точность (для итераций)
Epsilon = 0.00000001

# Параметры для наших разреженных матриц
MatrixParameter_a = 10  # При параметре a = 1 из условия сходимость не наблюдалась
MatrixParameter_b = -2

# ФункцияЮ генерирующая нашу матрицу по заданной размерности (a и b - параметры)
def GenerateSpecificMatrix(N, a, b):
    NeededMatrix = np.zeros((N, N))
    for i in range(N):
        NeededMatrix[i][i] = a
        NeededMatrix[N - i - 1][i] = b
    return NeededMatrix

#  Посчитать норму невязки || A*X = b || --> min
def ResidualRate(A, X):
    AX = np.dot(A, X)  # A*X
    AX_b = AX - b  # A*X - b
    return np.linalg.norm(AX_b)  # || A*X - b ||

# Решение СЛАУ методом Гаусса-Зейделя
def GaussSeidel(A, b, ResRateArr):
    StartTime = time.time()
    N = len(A)  # Запоминаем размер текущей матрицы A
    Xk = np.zeros(N)  # Текущий вектор-ответ
    CurrResidualRate = 1  # Текущая невязка
    IterationsAmount = 0  # Количество итераций
    while CurrResidualRate > Epsilon:  # До тех пор, пока невязка не станет меньше точности, выполняем итерации
        IterationsAmount += 1  # На каждой итерации приплюсовываем единицу к счетчику итераций
        Xk_1 = np.zeros(N)  # Вектор-ответ, который будет получен на следующей итерации
        for i in range(N):
            FirstSum = 0
            for j in range(i):
                FirstSum += (A[i][j] * Xk_1[j])

            SecondSum = 0
            for j in range(i + 1, N):
                SecondSum += (A[i][j] * Xk[j])

            Xk_1[i] = (-FirstSum - SecondSum + b[i]) / A[i][i]
        Xk = np.copy(Xk_1)  # Говорим, что теперь текущий вектор-ответ - это насчитанный нами в новой итерации вектор
        CurrResidualRate = ResidualRate(A, Xk)
        ResRateArr.append(CurrResidualRate)  # Добавляем текущую невязку в список невязок для графика

    print("После", IterationsAmount, "итерации был подобран Xk =", Xk, "\n")

    print("Общее время работы процесса: %s seconds" % (time.time() - StartTime), "\n")

    return IterationsAmount  # По завершении процесса возвращаем количество итераций, которое нам понадобилось

# Проверим работу программы на матрицах размерностей: 6, 8, 10, 12, 14, 100
ResRateArr = []  # Список списков ординат (норм невязки на разных итерациях для графика матрицы размерности i)
IterAmount = []  # Список количеств итераций, который понадобились каждому процессу
for i in range(6, 17, 2):
    if i == 16:
        i = 100  # Для размерности 100
    print("\n█████████████████████████████████████████████████████████████████████████████████████████\n")
    print("Размерность текущей матрицы N =", i, "\n")
    CurrRateArr = []  # Список ординат (норм невязки на разных итерациях) для графика матрицы размерности i
    A = GenerateSpecificMatrix(i, MatrixParameter_a, MatrixParameter_b)
    print("A =\n", A, "\n")
    X = np.ones(i)  # Пуская вектором-ответом всегда будет вектор, состоящий из N единичек (так удобнее)
    b = np.dot(A, X)  # Тогда вектор b = A*X
    print("При X =", X, ", b =", b, "\n")
    IterAmount.append(GaussSeidel(A, b, CurrRateArr))  # Запоминаем потребовавшееся количество итераций
    ResRateArr.append(CurrRateArr)  # Также запоминаем список невязок для текущего процесса

for i in range(6):
    LabelNum = 6 + i*2
    if LabelNum == 16:
        LabelNum = 100
    plt.semilogy(np.arange(1, IterAmount[i] + 1), ResRateArr[i], label="N = "+str(LabelNum))
plt.xlabel("Номер итерации")
plt.ylabel("Норма невязки на этой итерации")
plt.legend()
plt.show()