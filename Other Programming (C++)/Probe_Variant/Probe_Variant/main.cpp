#include <fstream>												// Для работы с файлами
#include <sstream>												// Для создания потока из строки (50-ая строка)
#include <string>												// Для создания строк типа string
#include <vector>												// Для создания контейнеров типа vector
#include <map>													// Для создания контейнеров типа map
#include <set>													// Для создания контейнеров типа set

using namespace std;											// Подключение пространства имён std

ofstream fout("ANSWER.TXT");									// Выходной поток fout в текстовый файл ответа на запросы ANSWER.TXT

bool OpenFile(const char* name, ifstream& fin)					// Параметры: 1) константный указатель на имя файла (чаровский массив), 2) входной поток для чтения
{ // Функция, проверяющая две вещи: 1) открылся ли файл, 2) пуст ли файл
	fin.open(name);	// Пробуем открыть файл

	if (!fin.is_open())
	{ // Если файл по какой-то причине НЕ открылся
		fout << "File " << name << " did not open!" << endl;	// Говорим, что файл с именем name не открылся
		return false;											// Возвращаем ложь
	}

	if (fin.peek() == EOF)
	{ // Если файл по какой-то причине остался пустым
		fout << "File " << name << " is empty!" << endl;		// Говорим, что файл с именем name пуст
		fin.close();											// Закрываем его, так как мы его уже открыли
		return false;											// Возвращаем ложь
	}

	return true;												// Если все ОК, возвращаем истину
}

int main()
{ // Основаная программа
	fout << "START\n\n";										// Говорим, что программа начала свою работу

	ifstream fin_d;												// Входной поток, из которого будем читать данные о городах и отелях из текстового файла DATA.TXT

	if (!OpenFile("DATA.TXT", fin_d))
	{ // Проверяем, открылся ли файл DATA.TXT
		fout.close();											// Если не открылся, то закрываем выходной файл ANSWER.TXT, так как мы его уже открыли
		return -1;												// Возвращаем из main код ошибки -1
	}

	map <string, vector<pair<string, int>>> towns;				// Создание контейнера из условия (map с ключом string и значением vector<pair<string, int>>)

	string temp = "";											// Переменная строки, которая послужит нам буфером

	while (getline(fin_d, temp))								// Пока содержимое файла DATA.TXT не закончилось, читаем каждую новую строку в переменную temp
	{
		istringstream towns_info(temp);							// Создание потока из строки temp

		string Town = "";										// Буферная строчная переменная для названий городов
		string HotelTemp = "";									// Буферная строчная переменная для названий отелей
		string StarsTemp = "";									// Буферная строчная переменная для количества звёзд (позже преобразовывается в число)

		getline(towns_info, Town, ';');							// Считываем из потока towns_info (это наша строка файла DATA.TXT) первую порцию данных (как правило первая порция данных в каждой строке - это название города) и помещаем ее в буферную переменную для города
		getline(towns_info, HotelTemp, ';');					// Считываем из потока towns_info (это наша строка файла DATA.TXT) первую порцию данных (как правило вторая порция данных в каждой строке - это название очередного отеля) и помещаем ее в буферную переменную для отеля
		getline(towns_info, StarsTemp, '\n');					// Считываем из потока towns_info (это наша строка файла DATA.TXT) первую порцию данных (как правило третья порция данных в каждой строке - это количество звёзд отеля) и помещаем ее в буферную переменную для количества звезд												

		map <string, vector<pair<string, int>>>::iterator it = towns.find(Town);	// Смотрим, есть ли уже город Town в нашем контейнере map (если да, итератор поставится на его местоположение в контейнере, а если нет, то на конец контейнера)

		if (it == towns.end())
		{ // Если города Town еще нет в нашем контейнере, то...
			vector<pair<string, int>> HotelList;					// Создание буферного контейнера vector<pair<string, int>> с отелями и их звёздами

			HotelList.push_back({ HotelTemp, stoi(StarsTemp) });	// Вставляем пару { имя_отеля, кол-во_звёзд } в вектор отелей города Town
			// Здесь, функция stoi(str) - преобразует строку str в число int (отсюда и название from String TO Int)

			towns.insert({ Town, HotelList });						// Вставляем в map пару { название_города, список_отелей }
		}
		else // Если такой город уже есть в нашем контейнере (тогда достаточно просто вставить данные о новом отеле в имеющийся город)
			towns[Town].push_back({ HotelTemp, stoi(StarsTemp) });
	} // Здесь, функция stoi(str) - преобразует строку str в число int (отсюда и название from String TO Int)

	ifstream fin_q;												// Входной поток, из которого будем читать данные о запросах из текстового файла QUERY.TXT

	if (!OpenFile("QUERY.TXT", fin_q))
	{ // Проверяем, открылся ли файл QUERY.TXT
		fin_d.close();											// Если не открылся, то закрываем входной файл DATA.TXT...
		fout.close();											// и выходной файл ANSWER.TXT, так как мы их уже открыли
		return -2;												// Возвращаем из main код ошибки -2
	}

	temp = "";													// На всякий случай зануляем буферную переменную строки temp

	while (getline(fin_q, temp))								// Пока содержимое файла QUERY.TXT не закончилось, читаем каждую новую строку в переменную temp
	{
		char symb = temp[0];									// Запоминаем первый символ строки temp, это будет номер запроса
		temp = temp.substr(2);									// Далее, так как переменная temp нам уже не нужна, мы запишем в нее все после ее второго символа (ведь нам уже не нужен первый символ с номером запроса, и нам подавно не нужен второй символ ':'), таким образом туда запишутся (если есть) данные для запроса 
																// Здесь метод класса String *.substr(num) возвращает всю оставшуюся часть строки после num-ого символа
		switch (symb)
		{ // В зависимости от номера запроса идём в разные ответвления
		case '1':
		{ // Запрос №1
			fout << "Query of the 1st type:\n";					// Говорим, что это запрос 1-ого типа

			fout << "Information about hotels in the town named " << temp << ":\n";	// Говорим, что мы начинаем выводить информацию обо всех отелях города temp

			if (towns.find(temp) == towns.end())
			{ // Если мы не нашли в map город с именем temp (в этом случае итератор сразу попадает на конец контейнера map)
				fout << "There is not such a town" << endl;		// Говорим, что такого города в контейнере нету
				break;											// Выходим из ветки
			}

			for (unsigned int i = 0; i < (*towns.find(temp)).second.size(); i++) // Выводим весь список отелей и их звёзд для города temp (для этого нужно пройтись по вектору (*towns.find(temp)).second
				fout << "Hotel " << (*towns.find(temp)).second[i].first << ", " << (*towns.find(temp)).second[i].second << " stars\n";

			fout << endl;										// Дополнительный отступ строки, чтобы отделять запросы друг от друга

			break;												// Выходим из ветки
		}
		case '2':
		{ // Запрос №2
			fout << "Query of the 2nd type:\n";					// Говорим, что это запрос 1-ого типа

			int count = 0;										// Счётчик для количества городов, в которых есть отели с именем temp

			for (map<string, vector<pair<string, int>>>::iterator it = towns.begin(); it != towns.end(); it++)	// Проходимся по всем городам контейнера map
				for (unsigned int i = 0; i < (*it).second.size(); i++)	// Для каждого города проходимся по всем его отелям
					if ((*it).second[i].first == temp)			// Проверяем, совпадает ли название очередного отеля с названием temp
						count++;								// Если да, делаем инкремент счетчика

			fout << "There are " << count << " towns with the hotel named " << temp << "\n"; // Выводим информацию о количестве городов с отелями имени temp

			fout << endl;										// Дополнительный отступ строки, чтобы отделять запросы друг от друга

			break;												// Выходим из ветки
		}
		case '3':
		{ // Запрос №3
			fout << "Query of the 3rd type:\n";					// Говорим, что это запрос 3-его типа

			set<pair<string, int>> Town_Stars;					// Создание дополнительного контейнера set<pair<string, int>>, представляющего собой множество пар { название_города, количество_звёзд_какого-либо_отеля_из_этого_города }

			for (map<string, vector<pair<string, int>>>::iterator it = towns.begin(); it != towns.end(); it++) // Проходимся по всем городам контейнера map
				for (unsigned int i = 0; i < (*it).second.size(); i++) // Для каждого города проходимся по всем его отелям
					Town_Stars.insert({ (*it).first, (*it).second[i].second }); // Вставляем в множество set пары { название_города, количество_звёзд_какого-либо_отеля_из_этого_города }

			for (set<pair<string, int>>::iterator it = Town_Stars.begin(); it != Town_Stars.end(); it++) // Проходимся по всем парам { название_города, количество_звёзд_какого-либо_отеля_из_этого_города } из накопившегося множества set
				fout << (*it).first << " - " << (*it).second << " stars\n"; // И выводим каждую пару

			fout << endl;										// Дополнительный отступ строки, чтобы отделять запросы друг от друга

			break;												// Выходим из ветки
		}
		default:												// Если же не встретилась ни одна из цифр 1, 2, 3, то...
			fout << "Incorrect query!" << endl;					// говорим, что запрос некорректный

			break;												// Выходим из ветки
		}
	}

	fout << "FINISH";											// Говорим, что программа закончила свою работу

	fout.close();												// Закрываем выходной текстовый файл ANSWER.TXT
	fin_d.close();												// Закрываем входной текстовый файл DATA.TXT
	fin_q.close();												// Закрываем входной текстовый файл QUERY.TXT

	return 0;													//Возвращаем из main код ошибки 0, что свидетельствует о том, что мы дошли до конца программы
}