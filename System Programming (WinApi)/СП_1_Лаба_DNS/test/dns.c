
/*************************************************************************
   LAB 1

	Edit this file ONLY!

*************************************************************************/

#include "dns.h"
#include "hashtable.h" // Подключаю хеш-таблицу
#include <stdio.h>
#include <string.h>

#define BUFFER_SIZE 1024 // Выбрали 1024, потому что это больше, чем любая длина строки в имени
#define _CRT_SECURE_NO_WARNINGS // Подключаем, потому что мы использовали небезопасные функции (fgets и т.д.)
#define HASHTABLE_SIZE 10000 // Выделяем размер под хеш-таблицу под уникальные домены(вертикальный массивчик)

IPADDRESS parseIP(const char* IP) // Парсинг IP-адресса
{
	IPADDRESS result = 0;
	int length = strlen(IP);
	unsigned int group = 0;
	for (int i = 0; i <= length; i++) // Проходимся по строке
	{
		if (IP[i] >= '0' && IP[i] <= '9') // Если нам встретилась цифра, то...
		{
			group = group * 10 + (IP[i] - '0'); // Переводим в десятичную систему счисления
		}
		else
		{
			result = result * 256 + group;
			group = 0;
		}
	}
	return result;
}

DNSHandle InitDNS()
{
	return (DNSHandle)Create_HT(HASHTABLE_SIZE); // Возвращаем хеш-таблицу
}




void LoadHostsFile(DNSHandle hDNS, const char* hostsFilePath)
{
	Hashtable* table = (Hashtable*)hDNS; // Создаем хеш-таблицу
	FILE* hosts = fopen(hostsFilePath, "r");
	char buffer[BUFFER_SIZE + 1];
	char IP[16];
	char domainName[BUFFER_SIZE + 1];
	/* Функция feof проверяет, достигнут ли конец файла, связанного с потоком, через параметр hosts.
	Возвращается значение, отличное от нуля, если конец файла был действительно достигнут.
    Вызов данной функции, как правило, выполняется после выполнения предыдущей операции с потоком,
	например операции считывания, которая постепенно двигает внутренний указатель файла в конец.
    Дальнейшие операции с файлом, после достижения его конца не будут выполняться до тех пор,
	пока внутренний указатель не будет сдвинут назад, функциями fseek или fsetpos.
	Таким образом индикатор положения внутреннего указателя будет иметь новое значение, отличное от EOF. */
	while (!feof(hosts)) // Пока данные не закончились...
	{
		/* Функция fgets считывает символы из потока и сохраняет их в виде строки в параметр buffer до тех пор,
		пока не наступит конец строки или пока не будет достигнут конец файла.
		Символ новой строки прекращает работу функции fgets, но он считается допустимым символом, и поэтому он копируется в строку buffer.
		Нулевой символ автоматически добавляется в строку после прочитанных символов, чтобы сигнализировать о конце строки.
		BUFFER_SIZE + 1 --> Максимальное количество символов для чтения, включая нулевой символ. */
		fgets(buffer, BUFFER_SIZE + 1, hosts);
		/* Функция sscanf() идентична функции scanf() во всем, кроме того, что данные считываются из массива, указанного аргументом buffer,
		а не из файла stdin. Возвращаемая величина равна количеству полей, значения которых действительно были при­своены переменным.
		В это количество не входят поля, пропущенные из-за использования моди­фикатора команды *. Возвращение 0 означает, что
		значение ни одного из полей не было присво­ено переменным, a EOF указывает на попытку чтения в конце строки. */
		sscanf(buffer, "%s%s", IP, domainName); // %s%s - считывает две строчки и помещает их: одну в IP, вторую в domainName
		Insert_In_HT(table, domainName, parseIP(IP)); // Вставка
	}
	fclose(hosts);
}



void ShutdownDNS(DNSHandle hDNS)
{
	Hashtable* table = (Hashtable*)hDNS;
	Delete_HT(table); // Удаление хеш-таблицы
}




IPADDRESS DnsLookUp(DNSHandle hDNS, const char* hostName)
{
	Hashtable* table = (Hashtable*)hDNS;
	return Find_In_HT(table, hostName); // Поиск в хеш-таблице
}


