#include <windows.h>
#include <iostream>

#include "ArrData.h"

using namespace std;

// Переменные
extern double max_value;							// Максимальное значение в массиве (по умолчанию равно наименьшему числу типа Double)
extern double min_value;							// Минимальное значение в массиве (по умолчанию равно наибольшему числу типа Double)
extern int max_i;									// Индекс максимального элемента массива (по умолчанию равен -1)
extern int min_i;									// Индекс минимального элемента массива (по умолчанию равен -1)

extern CRITICAL_SECTION cs_console;					// Критическая секция

// Функция min_max, записывающая минимальное и максимальное значение массива arr размера N
DWORD WINAPI MinMaxFunction(LPVOID ad)
{
	EnterCriticalSection(&cs_console);				// Поток входит в критическую секцию

	cout << "Поток Min_Max начал свою работу\n\n";

	LeaveCriticalSection(&cs_console);				// Поток выходит из критической секции

	ArrData* data = (ArrData*)ad;					// Меняем указатель LPVOID* на указатель нашей структуры
	max_value = DBL_MIN;							// Максимальное значение в массиве (по умолчанию равно наименьшему числу типа Double)
	min_value = DBL_MAX;							// Минимальное значение в массиве (по умолчанию равно наибольшему числу типа Double)
	max_i = -1;
	min_i = -1;

	// Поиск минимального и максимального элементов массива
	for (int i = 0; i < (*data).N; i++)
	{
		EnterCriticalSection(&cs_console);			// Поток входит в критическую секцию

		if ((*data).arr[i] < min_value)				// Сравниваем текущий элемент массива с текущим наименьшем значением
		{
			min_value = (*data).arr[i];				// Если оно меньше, то запоминаем новое наименьшее значение
			min_i = i;								// Также запоминаем индекс минимального элемента
		}

		LeaveCriticalSection(&cs_console);			// Поток выходит из критической секции

		Sleep(7);									// После очередного сравнения поток спит 7 миллисекунд

		EnterCriticalSection(&cs_console);			// Поток входит в критическую секцию

		if ((*data).arr[i] > max_value)				// Сравниваем текущий элемент массива с текущим наибольшом значением
		{
			max_value = (*data).arr[i];				// Если оно больше, то запоминаем новое наибольшее значение
			max_i = i;								// Также запоминаем индекс максимального элемента
		}

		Sleep(7);									// После очередного сравнения поток спит 7 миллисекунд

		LeaveCriticalSection(&cs_console);			// Поток выходит из критической секции
	}

	EnterCriticalSection(&cs_console);				// Поток входит в критическую секцию

	// Вывод информации о минимальном и максимальном элементах массива на консоль
	cout << "Минимальный элемент массива: " << min_value << " с индексом " << min_i << "\n";
	cout << "Максимальный элемент массива: " << max_value << " с индексом " << max_i << "\n\n";

	cout << "Поток Min_Max закончил свою работу\n\n";

	LeaveCriticalSection(&cs_console);				// Поток выходит из критической секции

	return 0;
}