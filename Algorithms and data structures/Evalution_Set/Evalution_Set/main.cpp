#include <iostream>
using namespace std;

int inv(int a, int m)
{
	return m % a == 0 ? 1 : (m - (long long)inv(m%a, a)*m / a);
}

int main()
{
	struct item { int prod, pow, pinv, k; };
	int n, a, b, p, i, S = 0;
	long long t, bin;
	cin >> n >> a >> b >> p;
	item *it = new item[n + 1];
	it[0].prod = 1; it[0].pow = 0;
	for (i = 1; i <= n; i++)
	{
		t = i; it[i].pow = it[i - 1].pow;
		while (t%p == 0)
		{
			t /= p;
			it[i].pow++;
		}
		it[i].k = t;
		it[i].prod = ((long long)it[i - 1].prod*t) % p;
	}
	it[n].pinv = inv(it[n].prod, p);
	for (i = n; i > 0; i--)
		it[i - 1].pinv = ((long long)it[i].pinv*it[i].k) % p;
	for (i = a; i <= b; i++)
	{
		if (it[n].pow - it[i].pow - it[n - i].pow == 0)
		{
			bin = ((((long long)it[n].prod*it[i].pinv) % p)*it[n - i].pinv) % p;
			t = (bin*bin) % p;
			t = (t*t) % p;
			S = (S + t * bin) % p;
		}
	}
	cout << S;
	delete it;
	return 0;
}

// јЋ√ќ–»“ћ
//
//  ≈сли p < n, то дл€ некоторых факториалов не существует обратного.“.к.k!и(n - k)!не взаимно просты с р.ќни дел€тс€ на р
//
//	» если допустим р маленькое, то почти все они дел€тс€ на р.
//
//	ѕоэтому мы будем считать не сами факториалы, а факториалы деленнные на максимальную степень р, вход€щую в их разложение
//
//	т.е.будем считать a[k] = k!/ p ^ r
//	где r такова, что это число a[k] уже не содержит степеней р, а значит оно взаимно просто с р.» у него существует обратный.
//
//	 ороче заводим массив из структур в количестве от 0 до n.в ней prod[k] - будет содержать эти самые a[k].
//
//	дальше, в итоге нужно отдельно дл€ каждого числа k!хранить степень r с которой простое р входит в k!
//
//	чтобы потом проверить в биномильном коэффициенте, сократ€тс€ полность эти p^r или нет.
//
//	≈сли сократились полностью - значит этот биномиальный коэффициент не 0 по модулю р.≈сли не полностью, то он 0.
//
//	и его можно не учитывать в сумме.
//
//	эти степени r у мен€ хр€н€тс€ в pow[k].
//
//	pinv[k] - это обратное к a[k]
//
//	ну а k в моей структуре, это индекс k деленный на степень простого p, который в него входит.
//
//	последнее - чисто вспомогательна€ штука.Ёто сделано, чтобы не считать обратный на каждом индексе k.
//
//	¬место этого мы считаем обратный один раз дл€ всего prod[n], который есть n!деленный на максимальную степень простого р, а потом просто домножаем на n, n - 1, n - 2, ... лишенные степеней простых, т.е.на то, что € обозвал k.