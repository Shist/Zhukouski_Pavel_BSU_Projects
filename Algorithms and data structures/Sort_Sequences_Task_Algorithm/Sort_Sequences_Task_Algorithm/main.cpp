#include <fstream>
#include <queue>

using namespace std;

int main()
{
	// Указываем имена входного и выходного файлов
	ifstream fin("input.txt");
	ofstream fout("output.txt");

	// Приоритетная очередь, которая (на основе бинарной кучи) будет хранить на верхушке самый маленький элемент (метод top() вернёт наименьшее число очереди)
	priority_queue<int, vector<int>, std::greater<int> > Q;

	// Инициализируем значения N и M
	int N = 0;
	int M = 0;

	// Считываем значения N и M из файлов
	fin >> N;
	fin >> M;

	// Инициализируем память под массив последовательностей и сами последовательности
	int** arr = new int* [N];
	for (int i = 0; i < N; i++)
		arr[i] = new int[M];

	// Заполняем все последовательности
	for (int i = 0; i < N; i++)
		for (int j = 0; j < M; j++)
			fin >> arr[i][j];

	for (int j = 0; j < M; j++)			// Проходимся по каждому столбцу по очереди
		for (int i = 0; i < N; i++)
		{
			Q.push(arr[i][j]);			// Кладём в приоритетную очередь следующий элемент
			if (Q.size() == M + 1)		// Если после довления нового элемента их стало больше, чем M, то...
			{
				fout << Q.top() << " ";	// Выводим самый маленький элемент, который есть на данный момент
				Q.pop();				// Удаляем самый маленький элемент, который есть на данный момент
			}
		}

	while (!Q.empty())					// Пока очередь не пуста...
	{
		fout << Q.top();				// Выводим самый маленький элемент, который есть на данный момент
		Q.pop();						// Удаляем самый маленький элемент, который есть на данный момент
		if (!Q.empty())					// Если очередь ещё не пуста, то...
			fout << " ";				// Печатаем ещё пробел
	}

	// Очищаем память
	for (int i = 0; i < N; i++)
		delete[] arr[i];
	delete[] arr;

	// Закрываем файлы
	fin.close();
	fout.close();

	// Возвращаем 0, чтобы показать, что программа отработала корректно, если сюда добралась
	return 0;
}