#include <fstream>
#include <vector>
#include <queue>
#include <stack>
using namespace std;

int main()
{
	ifstream fin("maze.in");
	ofstream fout("maze.out");
	short int M = 0; // Количество строк
	fin >> M; // Считываем количество строк
	short int N = 0; // Количество столбцов
	fin >> N; // Считываем количество столбцов
	short int Xs = 0; // Абсцисса начальной комнаты
	fin >> Xs; // Считываем абсциссы начальной комнаты
	short int Ys = 0; // Ордината начальной комнаты
	fin >> Ys; // Считываем ординату начальной комнаты
	short int Xf = 0; // Абсцисса конечной комнаты
	fin >> Xf; // Считываем абсциссу конечной комнаты
	short int Yf = 0; // Ордината конечной комнаты
	fin >> Yf; // Считываем ординату конечной комнаты
	pair<short int, short int> temp = make_pair(-1, -1); // Дефолтные координаты для каждой клетке в контейнере Path
	vector<vector<char>> Maze; // Вектор векторов чаров - контейнер, в котором храним информацию 0 или 1 о каждой комнате лабиринта
	Maze.reserve(M); // Заранее резервируем память под M строк
	for (int i = 0; i < M; i++)
	{
		Maze.push_back(vector<char>(N)); // Добавляем по вектору размера N (количество столбцов) на каждую строку для контейнера Maze
		for (int j = 0; j < N; j++)
			fin >> Maze[i][j]; // Вводим 0 или 1 для каждой комнаты
	}
	queue<pair<short int, short int>> Q; // Очередь, в которую будем помещать пары координат клеток во время поиска в ширину
	Q.push(make_pair(Xs - 1, Ys - 1)); // Изначально добавляем в очередь координаты стартовой вершины
	short int curr_X = 0; // Абсцисса текущей комнаты при поиске в ширину
	short int curr_Y = 0; // Ордината текущей комнаты при поиске в ширину
	while (!Q.empty()) // Если очередь не пуста, выполняем поиск в ширину
	{
		if (Maze[Xf - 1][Yf - 1] != '1')
			break; // Как только выяснится, что мы попали в финишную комнату, ломаем цикл
		curr_X = Q.front().first; // Берем из очереди абсциссу текущей комнаты
		curr_Y = Q.front().second; // Берем из очереди ординату текущей комнаты
		Q.pop(); // После чего удаляем координату этой комнаты из очереди
		if (curr_X - 1 >= 0 && Maze[curr_X - 1][curr_Y] == '1') // Если комната сверху существует и она доступна, то
		{
			Q.push(make_pair(curr_X - 1, curr_Y)); // Добавляем координаты этой комнаты в очередь, чтобы рассмотреть ее позже
			Maze[curr_X - 1][curr_Y] = '2'; // Помечаем, что мы уже пришли в эту комнату снизу
		}
		if (curr_Y + 1 < N && Maze[curr_X][curr_Y + 1] == '1') // Если комната справа существует и она доступна, то
		{
			Q.push(make_pair(curr_X, curr_Y + 1)); // Добавляем координаты этой комнаты в очередь, чтобы рассмотреть ее позже
			Maze[curr_X][curr_Y + 1] = '3'; // Помечаем, что мы уже пришли в эту комнату слева
		}
		if (curr_X + 1 < M && Maze[curr_X + 1][curr_Y] == '1') // Если комната снизу существует и она доступна, то
		{
			Q.push(make_pair(curr_X + 1, curr_Y)); // Добавляем координаты этой комнаты в очередь, чтобы рассмотреть ее позже
			Maze[curr_X + 1][curr_Y] = '4'; // Помечаем, что мы уже прошли эту комнату сверху
		}
		if (curr_Y - 1 >= 0 && Maze[curr_X][curr_Y - 1] == '1') // Если комната слева существует и она доступна, то
		{
			Q.push(make_pair(curr_X, curr_Y - 1)); // Добавляем координаты этой комнаты в очередь, чтобы рассмотреть ее позже
			Maze[curr_X][curr_Y - 1] = '5'; // Помечаем, что мы уже прошли эту комнату справа
		}
	}
	if (Xs == Xf && Ys == Yf) // Если старт и финиш совпадают, то
	{
		fout << 0 << endl << Xs << " " << Ys;
		return 0;
	}
	if (Maze[Xf - 1][Yf - 1] == '1')
	{ // Если доступа к финишной комнате не существует (комнату мы так и не прошли, она осталась 1), то
		fout << -1; // Выводим -1
		return 0; // Завершаем программу
	}
	stack<pair<short int, short int>> Route; // Создаем стек, чтобы положить в него нужный маршрут(задом наперед), а потом достать в нужном нам порядке и вывести
	int distance = 0; // Итоговое расстояние кратчайшего пути
	curr_X = Xf - 1; // Присваиваем к текущей абсциссе абсциссу финишной комнаты
	curr_Y = Yf - 1; // Присваиваем к текущей ординате ординату финишной комнаты
	while (true)
	{
		Route.push(make_pair(curr_X, curr_Y)); // Помещаем в стек очередную координату (начнем с последней и закончим стартовой)
		if (curr_X == Xs - 1 && curr_Y == Ys - 1)
			break; // Как только добавили в стек стартовую комнату, ломаем цикл
		distance++; // Длина пути есть количество комнат в пути минус единица, поэтому написали этот инкремент после break-а
		if (Maze[curr_X][curr_Y] == '2') // Если пришли сюда снизу
			temp = make_pair(curr_X + 1, curr_Y);
		else if (Maze[curr_X][curr_Y] == '3') // Если пришли сюда слева
			temp = make_pair(curr_X, curr_Y - 1);
		else if (Maze[curr_X][curr_Y] == '4') // Если пришли сюда сверху
			temp = make_pair(curr_X - 1, curr_Y);
		else if (Maze[curr_X][curr_Y] == '5') // Если пришли сюда справа
			temp = make_pair(curr_X, curr_Y + 1);
		curr_X = temp.first; // Берем абсциссу новой комнаты
		curr_Y = temp.second; // Берем ординату новой комнаты
	}
	fout << distance << endl; // Выводим итоговую длину пути
	fout << Route.top().first + 1 << " " << Route.top().second + 1; // Сразу выводим стартовую комнату (чтобы при выводе не делать лишний отступ строки)
	Route.pop(); // После чего удаляем ее из стека
	while (!Route.empty())
	{ // Пока стек не пуст
		fout << endl << Route.top().first + 1 << " " << Route.top().second + 1; // Выводим координаты очередной комнаты
		Route.pop(); // После чего удаляем их из стека
	}
	fin.close();
	fout.close();
	return 0;
}